 {
   "cell_type": "code",
   "execution_count": null,
   "id": "97b8bd14",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import time\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "from torch.utils.data import DataLoader, Subset\n",
    "from torchvision import datasets, transforms\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay\n",
    "\n",
    "# Image transformations for train, validation, and test sets\n",
    "image_transform = {\n",
    "    'train': transforms.Compose([\n",
    "        transforms.Grayscale(num_output_channels=1),\n",
    "        transforms.Resize(224),\n",
    "        transforms.CenterCrop(224),\n",
    "        transforms.ToTensor(),\n",
    "        transforms.Normalize(mean=[0.5], std=[0.5])\n",
    "    ])\n",
    "}\n",
    "\n",
    "# Dataset directories\n",
    "dataset = 'Data'\n",
    "train_dir = os.path.join(dataset, 'train')\n",
    "\n",
    "# Load datasets\n",
    "data = {\n",
    "    'train': datasets.ImageFolder(root=train_dir, transform=image_transform['train'])\n",
    "}\n",
    "\n",
    "# K-Fold Cross Validation Setup\n",
    "k_folds = 3\n",
    "kf = KFold(n_splits=k_folds, shuffle=True)\n",
    "\n",
    "# Dataset size\n",
    "train_data_size = len(data['train'])\n",
    "\n",
    "class NslNet(nn.Module):\n",
    "    def __init__(self, num_classes):\n",
    "        super(NslNet, self).__init__()\n",
    "        self.features = nn.Sequential(\n",
    "            nn.Conv2d(in_channels=1, out_channels=64, kernel_size=7, stride=2, padding=3),  # Grayscale input\n",
    "            nn.ReLU(inplace=True),\n",
    "            nn.Conv2d(64, 96, kernel_size=3, stride=1, padding=1),\n",
    "            nn.Conv2d(96, 192, kernel_size=3, stride=2, padding=1),\n",
    "            nn.Conv2d(192, 384, kernel_size=3, stride=1, padding=1),\n",
    "            nn.ReLU(inplace=True),\n",
    "            nn.MaxPool2d(kernel_size=2, stride=2),\n",
    "            nn.Conv2d(384, 384, kernel_size=3, stride=2, padding=1),\n",
    "            nn.Conv2d(384, 256, kernel_size=3, stride=1, padding=1),\n",
    "            nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1),\n",
    "            nn.ReLU(inplace=True),\n",
    "            nn.MaxPool2d(kernel_size=2, stride=2),\n",
    "        )\n",
    "        self.classifier = nn.Sequential(\n",
    "            nn.Linear(256 * 7 * 7, 4096),\n",
    "            nn.ReLU(inplace=True),\n",
    "            nn.Dropout(p=0.5),\n",
    "            nn.Linear(4096, num_classes),\n",
    "        )\n",
    "\n",
    "    def forward(self, x):\n",
    "        x = self.features(x)\n",
    "        x = x.view(x.size(0), 256 * 7 * 7)\n",
    "        x = self.classifier(x)\n",
    "        return x\n",
    "\n",
    "# Initialize model parameters\n",
    "num_classes = len(os.listdir(train_dir))\n",
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "loss_criterion = nn.CrossEntropyLoss()\n",
    "\n",
    "# Training function\n",
    "def train_valid(model, loss_criterion, optimizer, device, train_loader, valid_loader, epochs=30):\n",
    "    history = []\n",
    "    for epoch in range(epochs):\n",
    "        model.train()\n",
    "        train_loss, train_acc = 0.0, 0.0\n",
    "\n",
    "        for inputs, labels in train_loader:\n",
    "            inputs, labels = inputs.to(device), labels.to(device)\n",
    "            optimizer.zero_grad()\n",
    "            outputs = model(inputs)\n",
    "            loss = loss_criterion(outputs, labels)\n",
    "            loss.backward()\n",
    "            optimizer.step()\n",
    "\n",
    "            train_loss += loss.item() * inputs.size(0)\n",
    "            _, predictions = torch.max(outputs, 1)\n",
    "            correct_counts = predictions.eq(labels.data.view_as(predictions))\n",
    "            train_acc += torch.mean(correct_counts.type(torch.FloatTensor)).item() * inputs.size(0)\n",
    "\n",
    "        avg_train_loss = train_loss / len(train_loader.dataset)\n",
    "        avg_train_acc = train_acc / len(train_loader.dataset)\n",
    "\n",
    "        # Validation phase\n",
    "        model.eval()\n",
    "        valid_loss, valid_acc = 0.0, 0.0\n",
    "        with torch.no_grad():\n",
    "            for inputs, labels in valid_loader:\n",
    "                inputs, labels = inputs.to(device), labels.to(device)\n",
    "                outputs = model(inputs)\n",
    "                loss = loss_criterion(outputs, labels)\n",
    "\n",
    "                valid_loss += loss.item() * inputs.size(0)\n",
    "                _, predictions = torch.max(outputs, 1)\n",
    "                correct_counts = predictions.eq(labels.data.view_as(predictions))\n",
    "                valid_acc += torch.mean(correct_counts.type(torch.FloatTensor)).item() * inputs.size(0)\n",
    "\n",
    "        avg_valid_loss = valid_loss / len(valid_loader.dataset)\n",
    "        avg_valid_acc = valid_acc / len(valid_loader.dataset)\n",
    "\n",
    "        history.append([avg_train_loss, avg_valid_loss, avg_train_acc, avg_valid_acc])\n",
    "\n",
    "        print(f\"Epoch {epoch + 1}/{epochs} - Train Loss: {avg_train_loss:.4f}, Train Acc: {avg_train_acc:.4f}, \"\n",
    "              f\"Valid Loss: {avg_valid_loss:.4f}, Valid Acc: {avg_valid_acc:.4f}\")\n",
    "    return model, history\n",
    "\n",
    "# Store fold metrics and history for each fold\n",
    "all_fold_train_history = []\n",
    "all_fold_valid_history = []\n",
    "\n",
    "# Start K-Fold Cross Validation\n",
    "for fold, (train_idx, valid_idx) in enumerate(kf.split(data['train'])):\n",
    "    print(f'FOLD {fold + 1}/{k_folds}')\n",
    "    print('--------------------------------')\n",
    "\n",
    "    # Subset the dataset for the current fold\n",
    "    train_subset = Subset(data['train'], train_idx)\n",
    "    valid_subset = Subset(data['train'], valid_idx)\n",
    "\n",
    "    # Create data loaders for the current fold\n",
    "    train_loader = DataLoader(train_subset, batch_size=16, shuffle=True)\n",
    "    valid_loader = DataLoader(valid_subset, batch_size=16, shuffle=False)\n",
    "\n",
    "    # Initialize model for each fold\n",
    "    model = NslNet(num_classes=num_classes).to(device)\n",
    "\n",
    "    # Re-initialize optimizer for each fold\n",
    "    optimizer = torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)\n",
    "\n",
    "    # Train and validate the model for this fold\n",
    "    trained_model, history = train_valid(model, loss_criterion, optimizer, device, train_loader, valid_loader, epochs=25)\n",
    "\n",
    "    # Store fold-wise training and validation history\n",
    "    fold_train_history = [h[2] for h in history]  # Training Accuracy for each epoch\n",
    "    fold_valid_history = [h[3] for h in history]  # Validation Accuracy for each epoch\n",
    "    fold_train_loss = [h[0] for h in history]  # Training Loss for each epoch\n",
    "    fold_valid_loss = [h[1] for h in history]  # Validation Loss for each epoch\n",
    "\n",
    "    all_fold_train_history.append(fold_train_history)\n",
    "    all_fold_valid_history.append(fold_valid_history)\n",
    "\n",
    "    # Plot for this fold\n",
    "    plt.figure(figsize=(14, 10))\n",
    "\n",
    "    # Plotting Loss\n",
    "    plt.subplot(2, 2, 1)\n",
    "    plt.plot(fold_train_loss, label=f'Train Loss (Fold {fold + 1})')\n",
    "    plt.plot(fold_valid_loss, label=f'Valid Loss (Fold {fold + 1})', color='orange')\n",
    "    plt.legend()\n",
    "    plt.xlabel('Epoch Number')\n",
    "    plt.ylabel('Loss')\n",
    "    plt.title(f'Loss Curve - Fold {fold + 1}')\n",
    "\n",
    "    # Plotting Accuracy\n",
    "    plt.subplot(2, 2, 2)\n",
    "    plt.plot(fold_train_history, label=f'Train Accuracy (Fold {fold + 1})')\n",
    "    plt.plot(fold_valid_history, label=f'Valid Accuracy (Fold {fold + 1})', color='orange')\n",
    "    plt.legend()\n",
    "    plt.xlabel('Epoch Number')\n",
    "    plt.ylabel('Accuracy')\n",
    "    plt.title(f'Accuracy Curve - Fold {fold + 1}')\n",
    "\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(f'fold_{fold + 1}_loss_acc.png')\n",
    "    plt.show()\n",
    "\n",
    "# Plotting combined metrics for all folds\n",
    "plt.figure(figsize=(14, 10))\n",
    "\n",
    "# Plotting Loss Across Folds\n",
    "plt.subplot(2, 2, 1)\n",
    "for i in range(k_folds):\n",
    "    plt.plot(all_fold_train_history[i], label=f'Train Loss Fold {i + 1}')\n",
    "plt.legend()\n",
    "plt.xlabel('Epoch Number')\n",
    "plt.ylabel('Loss')\n",
    "plt.title('Train Loss Across Folds')\n",
    "\n",
    "plt.subplot(2, 2, 2)\n",
    "for i in range(k_folds):\n",
    "    plt.plot(all_fold_valid_history[i], label=f'Valid Loss Fold {i + 1}', color=f'C{i}')\n",
    "plt.legend()\n",
    "plt.xlabel('Epoch Number')\n",
    "plt.ylabel('Loss')\n",
    "plt.title('Validation Loss Across Folds')\n",
    "\n",
    "# Plotting Accuracy Across Folds\n",
    "plt.subplot(2, 2, 3)\n",
    "for i in range(k_folds):\n",
    "    plt.plot(all_fold_train_history[i], label=f'Train Accuracy Fold {i + 1}')\n",
    "plt.legend()\n",
    "plt.xlabel('Epoch Number')\n",
    "plt.ylabel('Accuracy')\n",
    "plt.title('Train Accuracy Across Folds')\n",
    "\n",
    "plt.subplot(2, 2, 4)\n",
    "for i in range(k_folds):\n",
    "    plt.plot(all_fold_valid_history[i], label=f'Valid Accuracy Fold {i + 1}', color=f'C{i}')\n",
    "plt.legend()\n",
    "plt.xlabel('Epoch Number')\n",
    "plt.ylabel('Accuracy')\n",
    "plt.title('Validation Accuracy Across Folds')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.savefig('combined_folds_loss_acc.png')\n",
    "plt.show()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
